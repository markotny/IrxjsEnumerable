{"ast":null,"code":"import _asyncToGenerator from \"C:/dev/IrxjsEnumerable/IrxjsEnumerable/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { Observable } from 'rxjs';\n/**\r\n * Stream server data (e.g. from endpoint returning IAsyncEnumerable)\r\n * @type T type of stream element\r\n * @param input input param of {@link fetch}\r\n * @param init init param of {@link fetch} (excluding abort signal)\r\n * @return stream of array elements one by one\r\n */\n\nexport function fromFetchStream(input, init) {\n  return new Observable(observer => {\n    const controller = new AbortController();\n    fetch(input, Object.assign(Object.assign({}, init), {\n      signal: controller.signal\n    })).then( /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (response) {\n        var _a;\n\n        console.log('got res', response, new Date());\n        const reader = (_a = response.body) === null || _a === void 0 ? void 0 : _a.getReader();\n\n        if (!reader) {\n          throw new Error('Failed to read response');\n        }\n\n        const decoder = new JsonStreamDecoder();\n\n        while (true) {\n          const {\n            done,\n            value\n          } = yield reader.read();\n          if (done) break;\n          if (!value) continue;\n          decoder.decodeChunk(value, item => observer.next(item));\n        }\n\n        observer.complete();\n        reader.releaseLock();\n      });\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }()).catch(err => observer.error(err));\n    return () => controller.abort();\n  });\n}\n/** Simple stream decoder, supports partial objects */\n\nclass JsonStreamDecoder {\n  constructor() {\n    /** item starts and ends at level 0, all nested objects are part of main item */\n    this.level = 0;\n    /** when last item is cut off and completed in beginning of next chunk */\n\n    this.partialItem = '';\n    this.decoder = new TextDecoder();\n  }\n  /** Decodes stream chunk. If root object is array, {@link decodedItemCallback} will be called for each array item. */\n\n\n  decodeChunk(value, decodedItemCallback) {\n    const chunk = this.decoder.decode(value);\n    let itemStart = 0;\n\n    for (let i = 0; i < chunk.length; i++) {\n      const char = chunk[i];\n\n      if (char === JTOKEN_START_OBJECT) {\n        if (this.level === 0) {\n          itemStart = i;\n        }\n\n        this.level++;\n      }\n\n      if (char === JTOKEN_END_OBJECT) {\n        this.level--;\n\n        if (this.level === 0) {\n          let item = chunk.substring(itemStart, i + 1);\n\n          if (this.partialItem) {\n            item = this.partialItem + item;\n            this.partialItem = '';\n          }\n\n          decodedItemCallback(JSON.parse(item));\n        }\n      }\n    } // last object didn't have closing token - it will come in next chunk\n\n\n    if (this.level !== 0) {\n      this.partialItem = chunk.substring(itemStart);\n    }\n  }\n\n}\n\nconst JTOKEN_START_OBJECT = '{';\nconst JTOKEN_END_OBJECT = '}';","map":{"version":3,"sources":["C:/dev/IrxjsEnumerable/IrxjsEnumerable/ClientApp/src/app/fromFetchStream.ts"],"names":["Observable","fromFetchStream","input","init","observer","controller","AbortController","fetch","Object","assign","signal","then","response","_a","console","log","Date","reader","body","getReader","Error","decoder","JsonStreamDecoder","done","value","read","decodeChunk","item","next","complete","releaseLock","catch","err","error","abort","constructor","level","partialItem","TextDecoder","decodedItemCallback","chunk","decode","itemStart","i","length","char","JTOKEN_START_OBJECT","JTOKEN_END_OBJECT","substring","JSON","parse"],"mappings":"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","sourcesContent":["import { Observable } from 'rxjs';\r\n/**\r\n * Stream server data (e.g. from endpoint returning IAsyncEnumerable)\r\n * @type T type of stream element\r\n * @param input input param of {@link fetch}\r\n * @param init init param of {@link fetch} (excluding abort signal)\r\n * @return stream of array elements one by one\r\n */\r\nexport function fromFetchStream(input, init) {\r\n    return new Observable(observer => {\r\n        const controller = new AbortController();\r\n        fetch(input, Object.assign(Object.assign({}, init), { signal: controller.signal }))\r\n            .then(async (response) => {\r\n            var _a;\r\n            console.log('got res', response, new Date());\r\n            const reader = (_a = response.body) === null || _a === void 0 ? void 0 : _a.getReader();\r\n            if (!reader) {\r\n                throw new Error('Failed to read response');\r\n            }\r\n            const decoder = new JsonStreamDecoder();\r\n            while (true) {\r\n                const { done, value } = await reader.read();\r\n                if (done)\r\n                    break;\r\n                if (!value)\r\n                    continue;\r\n                decoder.decodeChunk(value, item => observer.next(item));\r\n            }\r\n            observer.complete();\r\n            reader.releaseLock();\r\n        })\r\n            .catch(err => observer.error(err));\r\n        return () => controller.abort();\r\n    });\r\n}\r\n/** Simple stream decoder, supports partial objects */\r\nclass JsonStreamDecoder {\r\n    constructor() {\r\n        /** item starts and ends at level 0, all nested objects are part of main item */\r\n        this.level = 0;\r\n        /** when last item is cut off and completed in beginning of next chunk */\r\n        this.partialItem = '';\r\n        this.decoder = new TextDecoder();\r\n    }\r\n    /** Decodes stream chunk. If root object is array, {@link decodedItemCallback} will be called for each array item. */\r\n    decodeChunk(value, decodedItemCallback) {\r\n        const chunk = this.decoder.decode(value);\r\n        let itemStart = 0;\r\n        for (let i = 0; i < chunk.length; i++) {\r\n            const char = chunk[i];\r\n            if (char === JTOKEN_START_OBJECT) {\r\n                if (this.level === 0) {\r\n                    itemStart = i;\r\n                }\r\n                this.level++;\r\n            }\r\n            if (char === JTOKEN_END_OBJECT) {\r\n                this.level--;\r\n                if (this.level === 0) {\r\n                    let item = chunk.substring(itemStart, i + 1);\r\n                    if (this.partialItem) {\r\n                        item = this.partialItem + item;\r\n                        this.partialItem = '';\r\n                    }\r\n                    decodedItemCallback(JSON.parse(item));\r\n                }\r\n            }\r\n        }\r\n        // last object didn't have closing token - it will come in next chunk\r\n        if (this.level !== 0) {\r\n            this.partialItem = chunk.substring(itemStart);\r\n        }\r\n    }\r\n}\r\nconst JTOKEN_START_OBJECT = '{';\r\nconst JTOKEN_END_OBJECT = '}';\r\n"]},"metadata":{},"sourceType":"module"}