{"ast":null,"code":"import _asyncToGenerator from \"C:/dev/IrxjsEnumerable/IrxjsEnumerable/ClientApp/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";\nimport { Observable } from 'rxjs';\n/**\r\n * Stream server data (e.g. from endpoint returning IAsyncEnumerable)\r\n * @type T type of stream element\r\n * @param input input param of {@link fetch}\r\n * @param init init param of {@link fetch} (excluding abort signal)\r\n * @return stream of array elements one by one\r\n */\n\nexport function fromStreamSource(input, init) {\n  return new Observable(observer => {\n    const controller = new AbortController();\n    fetch(input, Object.assign(Object.assign({}, init), {\n      signal: controller.signal\n    })).then( /*#__PURE__*/function () {\n      var _ref = _asyncToGenerator(function* (response) {\n        var _a;\n\n        const reader = (_a = response.body) === null || _a === void 0 ? void 0 : _a.getReader();\n\n        if (!reader) {\n          throw new Error('Failed to read response');\n        }\n\n        const decoder = new JsonStreamDecoder();\n\n        while (true) {\n          console.log('reading next..');\n          const {\n            done,\n            value\n          } = yield reader.read();\n          if (done) break;\n          if (!value) continue;\n          console.log('got an item', new Date().getMilliseconds());\n          decoder.decodeBatch(value, item => observer.next(item));\n        }\n\n        observer.complete();\n        reader.releaseLock();\n      });\n\n      return function (_x) {\n        return _ref.apply(this, arguments);\n      };\n    }()).catch(err => observer.error(err));\n    return () => controller.abort();\n  });\n}\nconst JTOKEN_START_OBJECT = '{';\nconst JTOKEN_END_OBJECT = '}';\n/** Simple stream decoder, supports partial objects */\n\nclass JsonStreamDecoder {\n  constructor() {\n    /** item starts and ends at level 0, all nested objects are part of main item */\n    this.level = 0;\n    /** when last item is cut off and completed in beginning of next batch */\n\n    this.partialItem = '';\n    this.decoder = new TextDecoder();\n  }\n  /** Decodes stream batch. If root object is array, {@link decodedItemCallback} will be called for each array item. */\n\n\n  decodeBatch(value, decodedItemCallback) {\n    const batch = this.decoder.decode(value);\n    console.log('batch', batch);\n    let itemStart = 0; // index at which item starts\n\n    for (let i = 0; i < batch.length; i++) {\n      const char = batch[i];\n\n      if (char === JTOKEN_START_OBJECT) {\n        if (this.level === 0) {\n          itemStart = i;\n        }\n\n        this.level++;\n      }\n\n      if (char === JTOKEN_END_OBJECT) {\n        this.level--;\n\n        if (this.level === 0) {\n          let item = batch.substring(itemStart, i + 1);\n\n          if (this.partialItem) {\n            item = this.partialItem + item;\n            this.partialItem = '';\n          }\n\n          decodedItemCallback(JSON.parse(item));\n        }\n      }\n    } // last object didn't have closing token - it will come in next batch\n\n\n    if (this.level !== 0) {\n      this.partialItem = batch.substring(itemStart);\n    }\n  }\n\n}","map":{"version":3,"sources":["C:/dev/IrxjsEnumerable/IrxjsEnumerable/ClientApp/src/app/fromStreamSource.ts"],"names":["Observable","fromStreamSource","input","init","observer","controller","AbortController","fetch","Object","assign","signal","then","response","_a","reader","body","getReader","Error","decoder","JsonStreamDecoder","console","log","done","value","read","Date","getMilliseconds","decodeBatch","item","next","complete","releaseLock","catch","err","error","abort","JTOKEN_START_OBJECT","JTOKEN_END_OBJECT","constructor","level","partialItem","TextDecoder","decodedItemCallback","batch","decode","itemStart","i","length","char","substring","JSON","parse"],"mappings":"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","sourcesContent":["import { Observable } from 'rxjs';\r\n/**\r\n * Stream server data (e.g. from endpoint returning IAsyncEnumerable)\r\n * @type T type of stream element\r\n * @param input input param of {@link fetch}\r\n * @param init init param of {@link fetch} (excluding abort signal)\r\n * @return stream of array elements one by one\r\n */\r\nexport function fromStreamSource(input, init) {\r\n    return new Observable(observer => {\r\n        const controller = new AbortController();\r\n        fetch(input, Object.assign(Object.assign({}, init), { signal: controller.signal }))\r\n            .then(async (response) => {\r\n            var _a;\r\n            const reader = (_a = response.body) === null || _a === void 0 ? void 0 : _a.getReader();\r\n            if (!reader) {\r\n                throw new Error('Failed to read response');\r\n            }\r\n            const decoder = new JsonStreamDecoder();\r\n            while (true) {\r\n                console.log('reading next..');\r\n                const { done, value } = await reader.read();\r\n                if (done)\r\n                    break;\r\n                if (!value)\r\n                    continue;\r\n                console.log('got an item', new Date().getMilliseconds());\r\n                decoder.decodeBatch(value, item => observer.next(item));\r\n            }\r\n            observer.complete();\r\n            reader.releaseLock();\r\n        })\r\n            .catch(err => observer.error(err));\r\n        return () => controller.abort();\r\n    });\r\n}\r\nconst JTOKEN_START_OBJECT = '{';\r\nconst JTOKEN_END_OBJECT = '}';\r\n/** Simple stream decoder, supports partial objects */\r\nclass JsonStreamDecoder {\r\n    constructor() {\r\n        /** item starts and ends at level 0, all nested objects are part of main item */\r\n        this.level = 0;\r\n        /** when last item is cut off and completed in beginning of next batch */\r\n        this.partialItem = '';\r\n        this.decoder = new TextDecoder();\r\n    }\r\n    /** Decodes stream batch. If root object is array, {@link decodedItemCallback} will be called for each array item. */\r\n    decodeBatch(value, decodedItemCallback) {\r\n        const batch = this.decoder.decode(value);\r\n        console.log('batch', batch);\r\n        let itemStart = 0; // index at which item starts\r\n        for (let i = 0; i < batch.length; i++) {\r\n            const char = batch[i];\r\n            if (char === JTOKEN_START_OBJECT) {\r\n                if (this.level === 0) {\r\n                    itemStart = i;\r\n                }\r\n                this.level++;\r\n            }\r\n            if (char === JTOKEN_END_OBJECT) {\r\n                this.level--;\r\n                if (this.level === 0) {\r\n                    let item = batch.substring(itemStart, i + 1);\r\n                    if (this.partialItem) {\r\n                        item = this.partialItem + item;\r\n                        this.partialItem = '';\r\n                    }\r\n                    decodedItemCallback(JSON.parse(item));\r\n                }\r\n            }\r\n        }\r\n        // last object didn't have closing token - it will come in next batch\r\n        if (this.level !== 0) {\r\n            this.partialItem = batch.substring(itemStart);\r\n        }\r\n    }\r\n}\r\n"]},"metadata":{},"sourceType":"module"}